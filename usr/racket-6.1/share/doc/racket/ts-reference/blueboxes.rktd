19045
((3) 0 () 9 ((q lib "typed-racket/base-env/base-types.rkt") (q lib "typed-racket/base-env/prims.rkt") (q lib "typed-racket/base-env/base-types-extra.rkt") (q lib "typed-racket/typed-racket.rkt") (q lib "typed/racket/class.rkt") (q lib "typed/untyped-utils.rkt") (q lib "typed-racket/base-env/extra-procs.rkt") (q lib "typed/racket/base.rkt") (q lib "typed/scheme/base.rkt")) () (h ! (equal) ((c form c (c (? . 2) q Un)) q (20040 . 2)) ((c form c (c (? . 0) q Nonnegative-Exact-Rational)) q (1348 . 2)) ((c form c (c (? . 1) q letrec-values:)) q (18762 . 2)) ((c form c (c (? . 0) q Internal-Definition-Context)) q (2523 . 2)) ((c form c (c (? . 1) q for*/last)) q (9617 . 2)) ((c form c (c (? . 0) q Custodian)) q (2735 . 2)) ((c form c (c (? . 0) q Negative-Inexact-Real)) q (1139 . 2)) ((c form c (c (? . 1) q :query-type/result)) q (17391 . 2)) ((c form c (c (? . 1) q pdefine:)) q (20007 . 2)) ((c form c (c (? . 1) q for*/or:)) q (19492 . 2)) ((c form c (c (? . 2) q mu)) q (20050 . 2)) ((c form c (c (? . 1) q for*/list:)) q (19455 . 2)) ((c form c (c (? . 2) q All)) q (5894 . 3)) ((c form c (c (? . 0) q VectorTop)) q (3375 . 2)) ((c form c (c (? . 1) q for*/last:)) q (19437 . 2)) ((c form c (c (? . 0) q Input-Port)) q (2084 . 2)) ((c form c (c (? . 1) q for:)) q (19265 . 2)) ((c form c (c (? . 0) q Datum)) q (3873 . 2)) ((c form c (c (? . 2) q case→)) q (6106 . 2)) ((c def c (c (? . 1) q index?)) q (16769 . 3)) ((c form c (c (? . 1) q opt-lambda:)) q (17999 . 6)) ((c form c (c (? . 0) q Float)) q (70 . 2)) ((c form c (c (? . 1) q for/sum)) q (8805 . 2)) ((c form c (c (? . 1) q struct:)) q (19201 . 2)) ((c form c (c (? . 0) q Index)) q (1598 . 2)) ((c form c (c (? . 0) q Float-Nan)) q (796 . 2)) ((c form c (c (? . 0) q Pair)) q (20090 . 2)) ((c form c (c (? . 0) q String)) q (2017 . 2)) ((c form c (c (? . 0) q Exact-Positive-Integer)) q (289 . 2)) ((c form c (c (? . 0) q Thread-Cellof)) q (3683 . 2)) ((c form c (c (? . 1) q for/product:)) q (19798 . 2)) ((c form c (c (? . 1) q let:)) q (18467 . 3)) ((c form c (c (? . 0) q Positive-Integer)) q (265 . 2)) ((c form c (c (? . 0) q Negative-Flonum)) q (575 . 2)) ((c form c (c (? . 4) q define/augment)) q (15585 . 3)) ((c form c (c (? . 0) q Nonnegative-Inexact-Real)) q (1107 . 2)) ((c def c (c (? . 5) q syntax-local-typed-context?)) q (17192 . 2)) ((c form c (c (? . 0) q Listof)) q (3076 . 2)) ((c form c (c (? . 1) q :print-type)) q (17330 . 2)) ((c form c (c (? . 0) q Syntaxof)) q (3773 . 2)) ((c form c (c (? . 0) q Log-Level)) q (2863 . 2)) ((c form c (c (? . 0) q Inexact-Real-Positive-Zero)) q (1234 . 2)) ((c form c (c (? . 0) q Channelof)) q (3455 . 2)) ((c form c (c (? . 1) q cast)) q (12465 . 2)) ((c form c (c (? . 0) q Port)) q (2121 . 2)) ((c form c (c (? . 1) q for/sum:)) q (19818 . 2)) ((c form c (c (? . 0) q Bytes-Converter)) q (2688 . 2)) ((c form c (c (? . 0) q BoxTop)) q (3265 . 2)) ((c form c (c (? . 1) q for/list:)) q (19748 . 2)) ((c form c (c (? . 1) q λ)) q (7617 . 2)) ((c form c (c (? . 0) q Exact-Nonnegative-Integer)) q (346 . 2)) ((c form c (c (? . 1) q for*/product:)) q (19508 . 2)) ((c form c (c (? . 0) q TCP-Listener)) q (2809 . 2)) ((c form c (c (? . 0) q Positive-Inexact-Real)) q (1078 . 2)) ((c form c (c (? . 0) q PRegexp)) q (2187 . 2)) ((c form c (c (? . 2) q Instance)) q (16461 . 2)) ((c form c (c (? . 0) q Bytes)) q (2241 . 2)) ((c form c (c (? . 0) q Negative-ExtFlonum)) q (1817 . 2)) ((c form c (c (? . 0) q Boolean)) q (1977 . 2)) ((c form c (c (? . 0) q Namespace)) q (2254 . 2)) ((c form c (c (? . 0) q FlVector)) q (3324 . 2)) ((c form c (c (? . 0) q Byte-Regexp)) q (2202 . 2)) ((c form c (c (? . 1) q define-type-alias)) q (19864 . 2)) ((c form c (c (? . 0) q ClassTop)) q (16320 . 2)) ((c form c (c (? . 1) q for/hasheq)) q (8200 . 2)) ((c form c (c (? . 1) q do)) q (10271 . 7)) ((c form c (c (? . 0) q Will-Executor)) q (2983 . 2)) ((c form c (c (? . 0) q Continuation-Mark-KeyTop)) q (3971 . 2)) ((c form c (c (? . 0) q Flonum-Negative-Zero)) q (676 . 2)) ((c form c (c (? . 0) q Inspector)) q (2752 . 2)) ((c form c (c (? . 0) q Syntax)) q (3812 . 2)) ((c form c (c (? . 1) q for*/and)) q (9417 . 2)) ((c form c (c (? . 0) q MPairof)) q (3208 . 2)) ((c form c (c (? . 1) q for*/vector)) q (9206 . 2)) ((c form c (c (? . 1) q for*/fold:)) q (19360 . 2)) ((c form c (c (? . 0) q Positive-Single-Flonum)) q (831 . 2)) ((c form c (c (? . 0) q Compiled-Expression)) q (2496 . 2)) ((c form c (c (? . 0) q Struct-TypeTop)) q (6073 . 2)) ((c form c (c (? . 3) q #%top-interaction)) q (13348 . 2)) ((c form c (c (? . 1) q :query-type/args)) q (17354 . 2)) ((c form c (c (? . 0) q Real)) q (160 . 2)) ((c form c (c (? . 0) q Byte)) q (1565 . 2)) ((c form c (c (? . 0) q Custodian-Boxof)) q (3655 . 2)) ((c form c (c (? . 1) q lambda)) q (6826 . 26)) ((c form c (c (? . 0) q MPairTop)) q (3231 . 2)) ((c form c (c (? . 0) q Float-Positive-Zero)) q (704 . 2)) ((c form c (c (? . 0) q Float-Zero)) q (759 . 2)) ((c form c (c (? . 1) q for*/first)) q (9550 . 2)) ((c form c (c (? . 1) q for*)) q (10011 . 3)) ((c def c (c (? . 1) q default-continuation-prompt-tag)) q (13221 . 3)) ((c form c (c (? . 1) q letrec:)) q (18613 . 2)) ((c form c (c (? . 0) q Nonnegative-Real)) q (1468 . 2)) ((c form c (c (? . 8) q require/typed)) q (20116 . 12)) ((c form c (c (? . 1) q :)) q (12348 . 3)) ((c form c (c (? . 0) q Place-Channel)) q (2945 . 2)) ((c form c (c (? . 1) q for/hasheqv)) q (8267 . 2)) ((c form c (c (? . 1) q for*/fold)) q (10167 . 4)) ((c form c (c (? . 0) q Undefined)) q (2373 . 2)) ((c form c (c (? . 3) q #%module-begin)) q (13313 . 2)) ((c form c (c (? . 0) q Integer)) q (55 . 2)) ((c form c (c (? . 0) q Prompt-Tagof)) q (3886 . 2)) ((c form c (c (? . 1) q require/typed)) q (12604 . 15)) ((c form c (c (? . 0) q Single-Flonum)) q (97 . 2)) ((c form c (c (? . 1) q for/or)) q (8607 . 2)) ((c form c (c (? . 0) q Compiled-Module-Expression)) q (2462 . 2)) ((c form c (c (? . 1) q for*/extflvector:)) q (19335 . 2)) ((c form c (c (? . 0) q Log-Receiver)) q (2843 . 2)) ((c form c (c (? . 0) q Null)) q (2321 . 2)) ((c form c (c (? . 0) q Futureof)) q (3611 . 2)) ((c form c (c (? . 2) q Opaque)) q (6151 . 2)) ((c form c (c (? . 1) q define)) q (10453 . 30)) ((c form c (c (? . 1) q for*/vector:)) q (19546 . 2)) ((c form c (c (? . 0) q Read-Table)) q (2670 . 2)) ((c form c (c (? . 0) q Thread-CellTop)) q (3709 . 2)) ((c form c (c (? . 1) q letrec-values)) q (6642 . 2)) ((c form c (c (? . 1) q for/product)) q (8869 . 2)) ((c form c (c (? . 3) q let*-values:)) q (18824 . 2)) ((c form c (c (? . 0) q Inexact-Real-Zero)) q (1268 . 2)) ((c form c (c (? . 1) q for*/sum:)) q (19529 . 2)) ((c form c (c (? . 0) q False)) q (2004 . 2)) ((c form c (c (? . 0) q Inexact-Real)) q (118 . 2)) ((c form c (c (? . 1) q define:)) q (18952 . 7)) ((c form c (c (? . 4) q define/public)) q (15345 . 3)) ((c form c (c (? . 1) q typecheck-fail)) q (16821 . 8)) ((c form c (c (? . 0) q Positive-ExtFlonum)) q (1762 . 2)) ((c form c (c (? . 0) q Place)) q (2932 . 2)) ((c form c (c (? . 0) q Exact-Rational)) q (138 . 2)) ((c form c (c (? . 1) q struct)) q (11383 . 11)) ((c form c (c (? . 1) q let*)) q (6547 . 2)) ((c form c (c (? . 0) q Float-Complex)) q (192 . 2)) ((c form c (c (? . 1) q ann)) q (12427 . 2)) ((c form c (c (? . 0) q Nonpositive-Fixnum)) q (1719 . 2)) ((c form c (c (? . 1) q for*/lists)) q (10075 . 4)) ((c form c (c (? . 1) q define-predicate)) q (12313 . 2)) ((c form c (c (? . 0) q Thread-Group)) q (2894 . 2)) ((c form c (c (? . 1) q for/extflvector:)) q (19634 . 2)) ((c form c (c (? . 0) q Async-ChannelTop)) q (3523 . 2)) ((c form c (c (? . 4) q define/override)) q (15423 . 3)) ((c form c (c (? . 0) q Procedure)) q (5805 . 2)) ((c form c (c (? . 1) q λ:)) q (17878 . 2)) ((c form c (c (? . 1) q let/ec:)) q (18918 . 2)) ((c form c (c (? . 1) q for/fold:)) q (19658 . 2)) ((c form c (c (? . 0) q Nonpositive-Real)) q (1513 . 2)) ((c form c (c (? . 0) q ExtFlonum-Nan)) q (1956 . 2)) ((c form c (c (? . 5) q require/untyped-contract)) q (16986 . 5)) ((c form c (c (? . 1) q let-values)) q (6585 . 2)) ((c form c (c (? . 1) q for/list)) q (8070 . 2)) ((c form c (c (? . 0) q ExtFlonum-Negative-Zero)) q (1872 . 2)) ((c form c (c (? . 0) q Natural)) q (379 . 2)) ((c form c (c (? . 0) q Sexp)) q (3861 . 2)) ((c form c (c (? . 2) q Bot)) q (5794 . 2)) ((c form c (c (? . 0) q One)) q (1554 . 2)) ((c form c (c (? . 1) q define-struct/exec)) q (12000 . 5)) ((c form c (c (? . 1) q require-typed-struct)) q (19943 . 2)) ((c form c (c (? . 1) q for*/hasheq:)) q (19396 . 2)) ((c form c (c (? . 1) q for*/hash)) q (9003 . 2)) ((c form c (c (? . 0) q ExtFlonum-Zero)) q (1934 . 2)) ((c form c (c (? . 1) q for*:)) q (19566 . 2)) ((c form c (c (? . 0) q Thread)) q (2880 . 2)) ((c form c (c (? . 0) q Setof)) q (3437 . 2)) ((c form c (c (? . 0) q Negative-Fixnum)) q (1696 . 2)) ((c form c (c (? . 0) q Negative-Float)) q (553 . 2)) ((c form c (c (? . 0) q Promise)) q (3591 . 2)) ((c form c (c (? . 1) q for/lists:)) q (19765 . 2)) ((c form c (c (? . 0) q Nonnegative-Single-Flonum)) q (861 . 2)) ((c form c (c (? . 2) q Refinement)) q (20623 . 2)) ((c form c (c (? . 1) q for*/hasheq)) q (9069 . 2)) ((c form c (c (? . 0) q Single-Flonum-Nan)) q (1053 . 2)) ((c form c (c (? . 0) q Byte-PRegexp)) q (2221 . 2)) ((c form c (c (? . 1) q popt-lambda:)) q (18237 . 3)) ((c form c (c (? . 0) q Output-Port)) q (2102 . 2)) ((c def c (c (? . 6) q defined?)) q (16715 . 3)) ((c form c (c (? . 0) q UDP-Socket)) q (2791 . 2)) ((c form c (c (? . 0) q Single-Flonum-Negative-Zero)) q (957 . 2)) ((c form c (c (? . 0) q Pseudo-Random-Generator)) q (3004 . 2)) ((c form c (c (? . 1) q for/flvector:)) q (19613 . 2)) ((c form c (c (? . 0) q Nonpositive-Flonum)) q (623 . 2)) ((c form c (c (? . 2) q Tuple)) q (20060 . 2)) ((c form c (c (? . 1) q define-struct/exec:)) q (19238 . 2)) ((c form c (c (? . 1) q with-handlers)) q (13200 . 2)) ((c form c (c (? . 0) q Path-For-Some-System)) q (2145 . 2)) ((c form c (c (? . 0) q Async-Channelof)) q (3495 . 2)) ((c form c (c (? . 1) q do:)) q (19853 . 2)) ((c form c (c (? . 1) q for/first)) q (8674 . 2)) ((c form c (c (? . 0) q HashTable)) q (3392 . 2)) ((c form c (c (? . 0) q Prompt-TagTop)) q (3914 . 2)) ((c form c (c (? . 0) q ExtFlonum)) q (1745 . 2)) ((c form c (c (? . 0) q Nonnegative-Float)) q (502 . 2)) ((c form c (c (? . 1) q for*/lists:)) q (19473 . 2)) ((c form c (c (? . 2) q Top)) q (5783 . 2)) ((c form c (c (? . 2) q Vector)) q (3300 . 2)) ((c form c (c (? . 1) q for/vector)) q (8335 . 2)) ((c form c (c (? . 0) q Boxof)) q (3247 . 2)) ((c form c (c (? . 0) q FxVector)) q (3359 . 2)) ((c form c (c (? . 0) q Sexpof)) q (3842 . 2)) ((c form c (c (? . 0) q Flonum)) q (83 . 2)) ((c form c (c (? . 1) q define-struct)) q (11687 . 11)) ((c form c (c (? . 0) q Regexp)) q (2173 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Keyof)) q (3935 . 2)) ((c form c (c (? . 2) q Object)) q (16336 . 5)) ((c form c (c (? . 0) q Flonum-Positive-Zero)) q (731 . 2)) ((c form c (c (? . 0) q Nonpositive-ExtFlonum)) q (1843 . 2)) ((c form c (c (? . 1) q for*/or)) q (9482 . 2)) ((c form c (c (? . 2) q case->)) q (5841 . 2)) ((c form c (c (? . 1) q plet:)) q (18559 . 2)) ((c form c (c (? . 0) q Variable-Reference)) q (2295 . 2)) ((c form c (c (? . 0) q Positive-Float)) q (457 . 2)) ((c form c (c (? . 1) q for/vector:)) q (19834 . 2)) ((c form c (c (? . 1) q with-asserts)) q (16611 . 5)) ((c form c (c (? . 1) q provide:)) q (12378 . 2)) ((c form c (c (? . 0) q Nonpositive-Single-Flonum)) q (924 . 2)) ((c form c (c (? . 2) q ->)) q (4003 . 45)) ((c form c (c (? . 0) q Sequenceof)) q (3632 . 2)) ((c form c (c (? . 3) q for*/flvector)) q (9274 . 2)) ((c form c (c (? . 1) q require/typed/provide)) q (13150 . 2)) ((c form c (c (? . 1) q let-values:)) q (18703 . 2)) ((c form c (c (? . 1) q for*/hash:)) q (19378 . 2)) ((c form c (c (? . 0) q Module-Path-Index)) q (2409 . 2)) ((c form c (c (? . 0) q Nonnegative-ExtFlonum)) q (1788 . 2)) ((c form c (c (? . 0) q Positive-Real)) q (1447 . 2)) ((c form c (c (? . 2) q Values)) q (5947 . 2)) ((c form c (c (? . 0) q Keyword)) q (2031 . 2)) ((c form c (c (? . 1) q for*/first:)) q (19294 . 2)) ((c form c (c (? . 0) q Ephemeronof)) q (3731 . 2)) ((c form c (c (? . 0) q Security-Guard)) q (2769 . 2)) ((c form c (c (? . 1) q let/cc)) q (6760 . 2)) ((c form c (c (? . 0) q Inexact-Complex)) q (242 . 2)) ((c form c (c (? . 0) q Path)) q (2133 . 2)) ((c form c (c (? . 1) q for/hasheq:)) q (19692 . 2)) ((c form c (c (? . 1) q define-typed-struct)) q (19889 . 2)) ((c form c (c (? . 0) q HashTableTop)) q (3417 . 2)) ((c form c (c (? . 1) q for/last)) q (8740 . 2)) ((c form c (c (? . 0) q ExtFlVector)) q (3340 . 2)) ((c form c (c (? . 0) q Path-String)) q (3035 . 2)) ((c form c (c (? . 3) q for/extflvector)) q (8471 . 2)) ((c form c (c (? . 0) q Parameterization)) q (2711 . 2)) ((c form c (c (? . 0) q EOF)) q (2333 . 2)) ((c form c (c (? . 1) q for*/hasheqv:)) q (19416 . 2)) ((c form c (c (? . 1) q for/lists)) q (9817 . 4)) ((c form c (c (? . 0) q Positive-Exact-Rational)) q (1317 . 2)) ((c form c (c (? . 0) q Void)) q (2072 . 2)) ((c form c (c (? . 1) q for/hasheqv:)) q (19711 . 2)) ((c form c (c (? . 0) q Inexact-Real-Nan)) q (1293 . 2)) ((c form c (c (? . 1) q for*/flvector:)) q (19313 . 2)) ((c form c (c (? . 0) q Real-Zero)) q (1537 . 2)) ((c form c (c (? . 1) q make-predicate)) q (12286 . 2)) ((c form c (c (? . 2) q Parameter)) q (20073 . 2)) ((c form c (c (? . 0) q Nonpositive-Exact-Rational)) q (1413 . 2)) ((c form c (c (? . 0) q Flonum-Nan)) q (813 . 2)) ((c form c (c (? . 0) q Float-Negative-Zero)) q (649 . 2)) ((c form c (c (? . 0) q Impersonator-Property)) q (2641 . 2)) ((c form c (c (? . 2) q Class)) q (15745 . 16)) ((c form c (c (? . 1) q for*/product)) q (9748 . 2)) ((c form c (c (? . 1) q for/first:)) q (19595 . 2)) ((c form c (c (? . 0) q Positive-Fixnum)) q (1647 . 2)) ((c form c (c (? . 0) q Single-Flonum-Complex)) q (213 . 2)) ((c form c (c (? . 2) q ->*)) q (5429 . 14)) ((c form c (c (? . 0) q Positive-Byte)) q (1577 . 2)) ((c form c (c (? . 1) q for/hash:)) q (19675 . 2)) ((c def c (c (? . 6) q assert)) q (16496 . 6)) ((c form c (c (? . 1) q pcase-lambda:)) q (18356 . 3)) ((c form c (c (? . 1) q inst)) q (12485 . 3)) ((c form c (c (? . 1) q require-typed-struct/provide)) q (19971 . 2)) ((c form c (c (? . 0) q Logger)) q (2829 . 2)) ((c form c (c (? . 0) q Option)) q (6132 . 2)) ((c form c (c (? . 1) q for/fold)) q (9908 . 4)) ((c form c (c (? . 0) q Exact-Number)) q (172 . 2)) ((c form c (c (? . 1) q for/or:)) q (19783 . 2)) ((c form c (c (? . 0) q Char)) q (2060 . 2)) ((c form c (c (? . 0) q Syntax-E)) q (3826 . 2)) ((c form c (c (? . 7) q values)) q (20102 . 2)) ((c form c (c (? . 0) q Fixnum)) q (1633 . 2)) ((c form c (c (? . 0) q Pairof)) q (3054 . 2)) ((c form c (c (? . 0) q Evtof)) q (3755 . 2)) ((c form c (c (? . 1) q for/last:)) q (19731 . 2)) ((c form c (c (? . 0) q Resolved-Module-Path)) q (2434 . 2)) ((c form c (c (? . 0) q Semaphore)) q (2966 . 2)) ((c form c (c (? . 1) q :type)) q (17246 . 5)) ((c form c (c (? . 3) q for/flvector)) q (8402 . 2)) ((c form c (c (? . 0) q Namespace-Anchor)) q (2271 . 2)) ((c form c (c (? . 0) q Nonnegative-Flonum)) q (527 . 2)) ((c form c (c (? . 4) q define/private)) q (15665 . 3)) ((c form c (c (? . 0) q MListof)) q (3188 . 2)) ((c form c (c (? . 2) q Struct-Type)) q (6048 . 2)) ((c form c (c (? . 0) q Subprocess)) q (2914 . 2)) ((c form c (c (? . 1) q for/and)) q (8543 . 2)) ((c form c (c (? . 0) q Struct-Type-Property)) q (2613 . 2)) ((c form c (c (? . 0) q Inexact-Real-Negative-Zero)) q (1200 . 2)) ((c form c (c (? . 5) q define-typed/untyped-identifier)) q (17119 . 2)) ((c form c (c (? . 7) q define-type)) q (12125 . 6)) ((c form c (c (? . 1) q let*:)) q (18659 . 2)) ((c form c (c (? . 0) q Single-Flonum-Zero)) q (1027 . 2)) ((c form c (c (? . 0) q Zero)) q (445 . 2)) ((c form c (c (? . 0) q Nonnegative-Fixnum)) q (1670 . 2)) ((c form c (c (? . 2) q Parameterof)) q (3547 . 3)) ((c form c (c (? . 1) q for/hash)) q (8135 . 2)) ((c form c (c (? . 0) q ChannelTop)) q (3477 . 2)) ((c form c (c (? . 2) q ∀)) q (6121 . 2)) ((c form c (c (? . 2) q List*)) q (3158 . 2)) ((c form c (c (? . 0) q Negative-Integer)) q (394 . 2)) ((c form c (c (? . 1) q for)) q (7702 . 14)) ((c form c (c (? . 0) q Negative-Real)) q (1492 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Set)) q (2344 . 2)) ((c form c (c (? . 0) q Vectorof)) q (3279 . 2)) ((c form c (c (? . 1) q for/and:)) q (19579 . 2)) ((c form c (c (? . 2) q Struct)) q (6028 . 2)) ((c form c (c (? . 1) q for*/sum)) q (9683 . 2)) ((c form c (c (? . 0) q Any)) q (0 . 2)) ((c form c (c (? . 0) q Nonpositive-Float)) q (598 . 2)) ((c form c (c (? . 1) q letrec)) q (6507 . 2)) ((c form c (c (? . 1) q let)) q (6170 . 13)) ((c form c (c (? . 0) q Complex)) q (40 . 2)) ((c form c (c (? . 0) q Module-Path)) q (2390 . 2)) ((c form c (c (? . 1) q for*/and:)) q (19277 . 2)) ((c form c (c (? . 3) q with-type)) q (17425 . 10)) ((c form c (c (? . 0) q ExtFlonum-Positive-Zero)) q (1903 . 2)) ((c form c (c (? . 4) q define/pubment)) q (15505 . 3)) ((c form c (c (? . 0) q True)) q (1992 . 2)) ((c form c (c (? . 0) q Positive-Index)) q (1611 . 2)) ((c form c (c (? . 2) q Rec)) q (6009 . 2)) ((c form c (c (? . 0) q Flonum-Zero)) q (777 . 2)) ((c form c (c (? . 1) q define-struct:)) q (19216 . 2)) ((c form c (c (? . 0) q Nothing)) q (11 . 2)) ((c form c (c (? . 2) q U)) q (5822 . 2)) ((c form c (c (? . 0) q Special-Comment)) q (2590 . 2)) ((c form c (c (? . 2) q →)) q (6095 . 2)) ((c form c (c (? . 1) q lambda:)) q (17719 . 6)) ((c form c (c (? . 1) q for*/list)) q (8937 . 2)) ((c form c (c (? . 0) q Negative-Single-Flonum)) q (894 . 2)) ((c form c (c (? . 8) q require-typed-struct)) q (20563 . 2)) ((c form c (c (? . 1) q declare-refinement)) q (20591 . 2)) ((c form c (c (? . 7) q let*-values)) q (6702 . 2)) ((c form c (c (? . 2) q List)) q (3095 . 2)) ((c form c (c (? . 4) q class)) q (13383 . 45)) ((c form c (c (? . 1) q require/opaque-type)) q (19916 . 2)) ((c form c (c (? . 3) q for*/extflvector)) q (9344 . 2)) ((c form c (c (? . 0) q Nonnegative-Integer)) q (319 . 2)) ((c form c (c (? . 0) q Positive-Flonum)) q (479 . 2)) ((c form c (c (? . 0) q Symbol)) q (2046 . 2)) ((c form c (c (? . 0) q Nonpositive-Inexact-Real)) q (1168 . 2)) ((c form c (c (? . 0) q Pretty-Print-Style-Table)) q (2558 . 2)) ((c form c (c (? . 1) q case-lambda:)) q (18336 . 2)) ((c form c (c (? . 0) q Nonpositive-Integer)) q (418 . 2)) ((c form c (c (? . 1) q define-typed-struct/exec)) q (20647 . 2)) ((c form c (c (? . 0) q Identifier)) q (3794 . 2)) ((c form c (c (? . 2) q pred)) q (20023 . 2)) ((c form c (c (? . 1) q for*/hasheqv)) q (9137 . 2)) ((c form c (c (? . 1) q let/ec)) q (6793 . 2)) ((c form c (c (? . 1) q case-lambda)) q (7646 . 2)) ((c form c (c (? . 0) q Negative-Exact-Rational)) q (1382 . 2)) ((c form c (c (? . 0) q Single-Flonum-Positive-Zero)) q (992 . 2)) ((c form c (c (? . 1) q plambda:)) q (17908 . 3)) ((c form c (c (? . 0) q Number)) q (26 . 2)) ((c form c (c (? . 1) q let/cc:)) q (18884 . 2))))
syntax
Any
syntax
Nothing
syntax
Number
syntax
Complex
syntax
Integer
syntax
Float
syntax
Flonum
syntax
Single-Flonum
syntax
Inexact-Real
syntax
Exact-Rational
syntax
Real
syntax
Exact-Number
syntax
Float-Complex
syntax
Single-Flonum-Complex
syntax
Inexact-Complex
syntax
Positive-Integer
syntax
Exact-Positive-Integer
syntax
Nonnegative-Integer
syntax
Exact-Nonnegative-Integer
syntax
Natural
syntax
Negative-Integer
syntax
Nonpositive-Integer
syntax
Zero
syntax
Positive-Float
syntax
Positive-Flonum
syntax
Nonnegative-Float
syntax
Nonnegative-Flonum
syntax
Negative-Float
syntax
Negative-Flonum
syntax
Nonpositive-Float
syntax
Nonpositive-Flonum
syntax
Float-Negative-Zero
syntax
Flonum-Negative-Zero
syntax
Float-Positive-Zero
syntax
Flonum-Positive-Zero
syntax
Float-Zero
syntax
Flonum-Zero
syntax
Float-Nan
syntax
Flonum-Nan
syntax
Positive-Single-Flonum
syntax
Nonnegative-Single-Flonum
syntax
Negative-Single-Flonum
syntax
Nonpositive-Single-Flonum
syntax
Single-Flonum-Negative-Zero
syntax
Single-Flonum-Positive-Zero
syntax
Single-Flonum-Zero
syntax
Single-Flonum-Nan
syntax
Positive-Inexact-Real
syntax
Nonnegative-Inexact-Real
syntax
Negative-Inexact-Real
syntax
Nonpositive-Inexact-Real
syntax
Inexact-Real-Negative-Zero
syntax
Inexact-Real-Positive-Zero
syntax
Inexact-Real-Zero
syntax
Inexact-Real-Nan
syntax
Positive-Exact-Rational
syntax
Nonnegative-Exact-Rational
syntax
Negative-Exact-Rational
syntax
Nonpositive-Exact-Rational
syntax
Positive-Real
syntax
Nonnegative-Real
syntax
Negative-Real
syntax
Nonpositive-Real
syntax
Real-Zero
syntax
One
syntax
Byte
syntax
Positive-Byte
syntax
Index
syntax
Positive-Index
syntax
Fixnum
syntax
Positive-Fixnum
syntax
Nonnegative-Fixnum
syntax
Negative-Fixnum
syntax
Nonpositive-Fixnum
syntax
ExtFlonum
syntax
Positive-ExtFlonum
syntax
Nonnegative-ExtFlonum
syntax
Negative-ExtFlonum
syntax
Nonpositive-ExtFlonum
syntax
ExtFlonum-Negative-Zero
syntax
ExtFlonum-Positive-Zero
syntax
ExtFlonum-Zero
syntax
ExtFlonum-Nan
syntax
Boolean
syntax
True
syntax
False
syntax
String
syntax
Keyword
syntax
Symbol
syntax
Char
syntax
Void
syntax
Input-Port
syntax
Output-Port
syntax
Port
syntax
Path
syntax
Path-For-Some-System
syntax
Regexp
syntax
PRegexp
syntax
Byte-Regexp
syntax
Byte-PRegexp
syntax
Bytes
syntax
Namespace
syntax
Namespace-Anchor
syntax
Variable-Reference
syntax
Null
syntax
EOF
syntax
Continuation-Mark-Set
syntax
Undefined
syntax
Module-Path
syntax
Module-Path-Index
syntax
Resolved-Module-Path
syntax
Compiled-Module-Expression
syntax
Compiled-Expression
syntax
Internal-Definition-Context
syntax
Pretty-Print-Style-Table
syntax
Special-Comment
syntax
Struct-Type-Property
syntax
Impersonator-Property
syntax
Read-Table
syntax
Bytes-Converter
syntax
Parameterization
syntax
Custodian
syntax
Inspector
syntax
Security-Guard
syntax
UDP-Socket
syntax
TCP-Listener
syntax
Logger
syntax
Log-Receiver
syntax
Log-Level
syntax
Thread
syntax
Thread-Group
syntax
Subprocess
syntax
Place
syntax
Place-Channel
syntax
Semaphore
syntax
Will-Executor
syntax
Pseudo-Random-Generator
syntax
Path-String
syntax
(Pairof s t)
syntax
(Listof t)
syntax
(List t ...)
syntax
(List t ... trest ... bound)
syntax
(List* t t1 ... s)
syntax
(MListof t)
syntax
(MPairof t u)
syntax
MPairTop
syntax
(Boxof t)
syntax
BoxTop
syntax
(Vectorof t)
syntax
(Vector t ...)
syntax
FlVector
syntax
ExtFlVector
syntax
FxVector
syntax
VectorTop
syntax
(HashTable k v)
syntax
HashTableTop
syntax
(Setof t)
syntax
(Channelof t)
syntax
ChannelTop
syntax
(Async-Channelof t)
syntax
Async-ChannelTop
syntax
(Parameterof t)
(Parameterof s t)
syntax
(Promise t)
syntax
(Futureof t)
syntax
(Sequenceof t)
syntax
(Custodian-Boxof t)
syntax
(Thread-Cellof t)
syntax
Thread-CellTop
syntax
(Ephemeronof t)
syntax
(Evtof t)
syntax
(Syntaxof t)
syntax
Identifier
syntax
Syntax
syntax
Syntax-E
syntax
(Sexpof t)
syntax
Sexp
syntax
Datum
syntax
(Prompt-Tagof s t)
syntax
Prompt-TagTop
syntax
(Continuation-Mark-Keyof t)
syntax
Continuation-Mark-KeyTop
syntax
(-> dom ... rng optional-filter)
(-> dom ... rest * rng)
(-> dom ... rest ooo bound rng)
(dom ... -> rng optional-filter)
(dom ... rest * -> rng)
(dom ... rest ooo bound -> rng)
 
            ooo = ...
                   
            dom = type
                | mandatory-kw
                | optional-kw
                   
   mandatory-kw = keyword type
                   
    optional-kw = [keyword type]
                   
optional-filter = 
                | : type
                | : pos-filter neg-filter object
                   
     pos-filter = 
                | #:+ proposition ...
                   
     neg-filter = 
                | #:- proposition ...
                   
         object = 
                | #:object index
                   
    proposition = type
                | (! type)
                | (type @ path-elem ... index)
                | (! type @ path-elem ... index)
                | (and proposition ...)
                | (or proposition ...)
                | (implies proposition ...)
                   
      path-elem = car
                | cdr
                   
          index = positive-integer
                | (positive-integer positive-integer)
                | identifier
syntax
(->* (mandatory-dom ...) optional-doms rest rng)
 
mandatory-dom = type
              | keyword type
                 
optional-doms = 
              | (optional-dom ...)
                 
 optional-dom = type
              | keyword type
                 
         rest = 
              | #:rest type
syntax
Top
syntax
Bot
syntax
Procedure
syntax
(U t ...)
syntax
(case-> fun-ty ...)
syntax
(t t1 t2 ...)
syntax
(All (a ...) t)
(All (a ... a ooo) t)
syntax
(Values t ...)
syntax
v
syntax
(quote val)
syntax
i
syntax
(Rec n t)
syntax
(Struct st)
syntax
(Struct-Type st)
syntax
Struct-TypeTop
syntax
→
syntax
case→
syntax
∀
syntax
(Option t)
syntax
(Opaque t)
syntax
(let maybe-tvars (binding ...) . body)
(let loop maybe-ret (binding ...) . body)
 
    binding = [var e]
            | [var : type e]
               
maybe-tvars = 
            | #:forall (tvar ...)
            | #:∀ (tvar ...)
               
  maybe-ret = 
            | : type0
syntax
(letrec (binding ...) . body)
syntax
(let* (binding ...) . body)
syntax
(let-values ([(var+type ...) e] ...) . body)
syntax
(letrec-values ([(var+type ...) e] ...) . body)
syntax
(let*-values ([(var+type ...) e] ...) . body)
syntax
(let/cc v : t . body)
syntax
(let/ec v : t . body)
syntax
(lambda maybe-tvars formals maybe-ret . body)
 
    formals = (formal ...)
            | (formal ... . rst)
               
     formal = var
            | [var default-expr]
            | [var : type]
            | [var : type default-expr]
            | keyword var
            | keyword [var : type]
            | keyword [var : type default-expr]
               
        rst = var
            | [var : type *]
            | [var : type ooo bound]
               
maybe-tvars = 
            | #:forall (tvar ...)
            | #:∀ (tvar ...)
            | #:forall (tvar ... ooo)
            | #:∀ (tvar ... ooo)
               
  maybe-ret = 
            | : type
syntax
(λ formals . body)
syntax
(case-lambda maybe-tvars [formals body] ...)
syntax
(for type-ann-maybe (for-clause ...)
  expr ...+)
 
type-ann-maybe = 
               | : u
                  
    for-clause = [id : t seq-expr]
               | [(binding ...) seq-expr]
               | [id seq-expr]
               | #:when guard
                  
       binding = id
               | [id : t]
syntax
(for/list type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/hash type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/hasheq type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/hasheqv type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/vector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/flvector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/extflvector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/and type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/or   type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/first type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/last type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/sum type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/product type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/list type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/hash type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/hasheq type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/hasheqv type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/vector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/flvector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/extflvector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/and type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/or   type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/first type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/last type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/sum type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/product type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/lists type-ann-maybe ([id : t] ...)
  (for-clause ...)
  expr ...+)
syntax
(for/fold  type-ann-maybe ([id : t init-expr] ...)
  (for-clause ...)
  expr ...+)
syntax
(for* void-ann-maybe (for-clause ...)
  expr ...+)
syntax
(for*/lists type-ann-maybe ([id : t] ...)
  (for-clause ...)
  expr ...+)
syntax
(for*/fold  type-ann-maybe ([id : t init-expr] ...)
  (for-clause ...)
  expr ...+)
syntax
(do : u ([id : t init-expr step-expr-maybe] ...)
        (stop?-expr finish-expr ...)
  expr ...+)
 
step-expr-maybe = 
                | step-expr
syntax
(define maybe-tvars v maybe-ann e)
(define maybe-tvars header maybe-ann . body)
 
     header = (function-name . formals)
            | (header . formals)
               
    formals = (formal ...)
            | (formal ... . rst)
               
     formal = var
            | [var default-expr]
            | [var : type]
            | [var : type default-expr]
            | keyword var
            | keyword [var : type]
            | keyword [var : type default-expr]
               
        rst = var
            | [var : type *]
            | [var : type ooo bound]
               
maybe-tvars = 
            | #:forall (tvar ...)
            | #:∀ (tvar ...)
            | #:forall (tvar ... ooo)
            | #:∀ (tvar ... ooo)
               
  maybe-ann = 
            | : type
syntax
(struct maybe-type-vars name-spec ([f : t] ...) options ...)
 
maybe-type-vars = 
                | (v ...)
                   
      name-spec = name
                | name parent
                   
        options = #:transparent
                | #:mutable
syntax
(define-struct maybe-type-vars name-spec ([f : t] ...) options ...)
 
maybe-type-vars = 
                | (v ...)
                   
      name-spec = name
                | (name parent)
                   
        options = #:transparent
                | #:mutable
syntax
(define-struct/exec name-spec ([f : t] ...) [e : proc-t])
 
name-spec = name
          | (name parent)
syntax
(define-type name t maybe-omit-def)
(define-type (name v ...) t maybe-omit-def)
 
maybe-omit-def = #:omit-define-syntaxes
               | 
syntax
(make-predicate t)
syntax
(define-predicate name t)
syntax
(: v t)
(: v : t)
syntax
(provide: [v t] ...)
syntax
#{v : t}
syntax
(ann e t)
syntax
#{e :: t}
syntax
(cast e t)
syntax
(inst e t ...)
(inst e t ... t ooo bound)
syntax
#{e @ t ...}
syntax
#{e @ t ... t ooo bound}
syntax
(require/typed m rt-clause ...)
 
    rt-clause = [maybe-renamed t]
              | [#:struct name ([f : t] ...)
                     struct-option ...]
              | [#:struct (name parent) ([f : t] ...)
                     struct-option ...]
              | [#:opaque t pred]
                 
maybe-renamed = id
              | (orig-id new-id)
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
syntax
(require/typed/provide m rt-clause ...)
syntax
with-handlers
procedure
(default-continuation-prompt-tag)
 -> (-> (Prompt-Tagof Any (Any -> Any)))
syntax
(#%module-begin form ...)
syntax
(#%top-interaction . form)
syntax
(class superclass-expr
  maybe-type-parameters
  class-clause ...)
 
         class-clause = (inspect inspector-expr)
                      | (init init-decl ...)
                      | (init-field init-decl ...)
                      | (init-rest id/type)
                      | (field field-decl ...)
                      | (inherit-field field-decl ...)
                      | (public maybe-renamed/type ...)
                      | (pubment maybe-renamed/type ...)
                      | (override maybe-renamed/type ...)
                      | (augment maybe-renamed/type ...)
                      | (private id/type ...)
                      | (inherit id ...)
                      | method-definition
                      | definition
                      | expr
                      | (begin class-clause ...)
                         
maybe-type-parameters = 
                      | #:forall (type-variable ...)
                      | #:∀ (type-variable ...)
                         
            init-decl = id/type
                      | [renamed]
                      | [renamed : type-expr]
                      | [maybe-renamed default-value-expr]
                      | [maybe-renamed : type-expr default-value-expr]
                         
           field-decl = (maybe-renamed default-value-expr)
                      | (maybe-renamed : type-expr default-value-expr)
                         
              id/type = id
                      | [id : type-expr]
                         
   maybe-renamed/type = maybe-renamed
                      | [maybe-renamed : type-expr]
                         
        maybe-renamed = id
                      | renamed
                         
              renamed = (internal-id external-id)
syntax
(define/public id expr)
(define/public (id . formals) body ...+)
syntax
(define/override id expr)
(define/override (id . formals) body ...+)
syntax
(define/pubment id expr)
(define/pubment (id . formals) body ...+)
syntax
(define/augment id expr)
(define/augment (id . formals) body ...+)
syntax
(define/private id expr)
(define/private (id . formals) body ...+)
syntax
(Class class-type-clause ...)
 
class-type-clause = name+type
                  | (init init-type ...)
                  | (init-field init-type ...)
                  | (init-rest name+type)
                  | (field name+type ...)
                  | (augment name+type ...)
                  | #:implements type-alias-id
                  | #:row-var row-var-id
                     
        init-type = name+type
                  | [id type #:optional]
                     
        name+type = [id type]
syntax
ClassTop
syntax
(Object object-type-clause ...)
 
object-type-clause = name+type
                   | (field name+type ...)
syntax
(Instance class-type-expr)
procedure
(assert v) -> A
  v : (U #f A)
(assert v p?) -> B
  v : A
  p? : (A -> Any : B)
syntax
(with-asserts ([id maybe-pred] ...) body ...+)
 
maybe-pred = 
           | predicate
procedure
(defined? v) -> boolean?
  v : any/c
procedure
(index? v) -> boolean?
  v : any/c
syntax
(typecheck-fail orig-stx maybe-msg maybe-id)
 
maybe-msg = 
          | msg-string
             
 maybe-id = 
          | #:covered-id id
syntax
(require/untyped-contract maybe-begin module [name subtype] ...)
 
maybe-begin = 
            | (begin expr ...)
syntax
(define-typed/untyped-identifier name typed-name untyped-name)
procedure
(syntax-local-typed-context?) -> boolean?
syntax
(:type maybe-verbose t)
 
maybe-verbose = 
              | #:verbose
syntax
(:print-type e)
syntax
(:query-type/args f t ...)
syntax
(:query-type/result f t)
syntax
(with-type result-spec fv-clause body ...+)
(with-type export-spec fv-clause body ...+)
 
  fv-clause = 
            | #:freevars ([id fv-type] ...)
               
result-spec = #:result type
               
export-spec = ([export-id export-type] ...)
syntax
(lambda: formals . body)
 
formals = ([v : t] ...)
        | ([v : t] ... v : t *)
        | ([v : t] ... v : t ooo bound)
syntax
(λ: formals . body)
syntax
(plambda: (a ...) formals . body)
(plambda: (a ... b ooo) formals . body)
syntax
(opt-lambda: formals . body)
 
formals = ([v : t] ... [v : t default] ...)
        | ([v : t] ... [v : t default] ... v : t *)
        | ([v : t] ... [v : t default] ... v : t ooo bound)
syntax
(popt-lambda: (a ...) formals . body)
(popt-lambda: (a ... a ooo) formals . body)
syntax
case-lambda:
syntax
(pcase-lambda: (a ...) [formals body] ...)
(pcase-lambda: (a ... b ooo) [formals body] ...)
syntax
(let: ([v : t e] ...) . body)
(let: loop : t0 ([v : t e] ...) . body)
syntax
(plet: (a ...) ([v : t e] ...) . body)
syntax
(letrec: ([v : t e] ...) . body)
syntax
(let*: ([v : t e] ...) . body)
syntax
(let-values: ([([v : t] ...) e] ...) . body)
syntax
(letrec-values: ([([v : t] ...) e] ...) . body)
syntax
(let*-values: ([([v : t] ...) e] ...) . body)
syntax
(let/cc: v : t . body)
syntax
(let/ec: v : t . body)
syntax
(define: v : t e)
(define: (a ...) v : t e)
(define: (a ... a ooo) v : t e)
(define: (f . formals) : t . body)
(define: (a ...) (f . formals) : t . body)
(define: (a ... a ooo) (f . formals) : t . body)
syntax
struct:
syntax
define-struct:
syntax
define-struct/exec:
syntax
for:
syntax
for*/and:
syntax
for*/first:
syntax
for*/flvector:
syntax
for*/extflvector:
syntax
for*/fold:
syntax
for*/hash:
syntax
for*/hasheq:
syntax
for*/hasheqv:
syntax
for*/last:
syntax
for*/list:
syntax
for*/lists:
syntax
for*/or:
syntax
for*/product:
syntax
for*/sum:
syntax
for*/vector:
syntax
for*:
syntax
for/and:
syntax
for/first:
syntax
for/flvector:
syntax
for/extflvector:
syntax
for/fold:
syntax
for/hash:
syntax
for/hasheq:
syntax
for/hasheqv:
syntax
for/last:
syntax
for/list:
syntax
for/lists:
syntax
for/or:
syntax
for/product:
syntax
for/sum:
syntax
for/vector:
syntax
do:
syntax
define-type-alias
syntax
define-typed-struct
syntax
require/opaque-type
syntax
require-typed-struct
syntax
require-typed-struct/provide
syntax
pdefine:
syntax
(pred t)
syntax
Un
syntax
mu
syntax
Tuple
syntax
Parameter
syntax
Pair
syntax
values
syntax
(require/typed m rt-clause ...)
 
    rt-clause = [r t]
              | [struct name ([f : t] ...)
                     struct-option ...]
              | [struct (name parent) ([f : t] ...)
                     struct-option ...]
              | [opaque t pred]
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
syntax
require-typed-struct
syntax
(declare-refinement id)
syntax
(Refinement id)
syntax
(define-typed-struct/exec forms ...)
