8515
((3) 0 () 9 ((q lib "plai/main.rkt") (q lib "plai/scribblings/fake-collector.rkt") (q lib "plai/gc2/mutator.rkt") (q lib "plai/mutator.rkt") (q lib "plai/collector.rkt") (q lib "plai/gc2/collector.rkt") (q lib "plai/scribblings/fake-collector2.rkt") (q lib "plai/gc2/random-mutator.rkt") (q lib "plai/random-mutator.rkt")) () (h ! (equal) ((c form c (c (? . 0) q plai-all-test-results)) q (968 . 2)) ((c form c (c (? . 4) q with-heap)) q (1625 . 4)) ((c form c (c (? . 3) q or)) q (2736 . 2)) ((c def c (c (? . 0) q halt-on-errors)) q (647 . 3)) ((c def c (c (? . 1) q gc:alloc-flat)) q (1912 . 3)) ((c def c (c (? . 1) q gc:rest)) q (2152 . 3)) ((c form c (c (? . 2) q begin)) q (7385 . 2)) ((c def c (c (? . 2) q even?)) q (7758 . 2)) ((c def c (c (? . 6) q gc:deref)) q (6007 . 3)) ((c def c (c (? . 3) q =)) q (3283 . 2)) ((c form c (c (? . 2) q cond)) q (7274 . 2)) ((c def c (c (? . 3) q /)) q (3207 . 2)) ((c def c (c (? . 5) q set-root!)) q (5516 . 4)) ((c form c (c (? . 4) q with-roots)) q (1716 . 4)) ((c form c (c (? . 0) q test/exn)) q (367 . 2)) ((c def c (c (? . 2) q odd?)) q (7785 . 2)) ((c def c (c (? . 4) q set-root!)) q (1461 . 4)) ((c def c (c (? . 4) q location?)) q (1051 . 3)) ((c form c (c (? . 2) q test/value=?)) q (8607 . 2)) ((c def c (c (? . 1) q gc:first)) q (2077 . 3)) ((c def c (c (? . 2) q cons)) q (8099 . 4)) ((c def c (c (? . 5) q make-root)) q (5659 . 5)) ((c def c (c (? . 2) q error)) q (7560 . 2)) ((c def c (c (? . 2) q *)) q (7712 . 2)) ((c def c (c (? . 2) q set-rest!)) q (8386 . 4)) ((c def c (c (? . 3) q first)) q (3692 . 3)) ((c def c (c (? . 4) q heap-size)) q (997 . 2)) ((c def c (c (? . 6) q gc:alloc-flat)) q (6072 . 3)) ((c form c (c (? . 0) q test)) q (259 . 2)) ((c def c (c (? . 6) q gc:cons)) q (6142 . 4)) ((c form c (c (? . 4) q get-root-set)) q (1368 . 2)) ((c form c (c (? . 0) q type-case)) q (104 . 6)) ((c def c (c (? . 3) q add1)) q (3059 . 2)) ((c form c (c (? . 3) q begin)) q (2857 . 2)) ((c def c (c (? . 2) q /)) q (7735 . 2)) ((c def c (c (? . 0) q plai-ignore-exn-strings)) q (887 . 3)) ((c form c (c (? . 2) q let)) q (7319 . 2)) ((c def c (c (? . 5) q root?)) q (5170 . 3)) ((c form c (c (? . 5) q get-root-set)) q (5432 . 2)) ((c def c (c (? . 6) q gc:closure-env-ref)) q (6935 . 4)) ((c def c (c (? . 0) q plai-catch-test-exn)) q (561 . 3)) ((c def c (c (? . 3) q sub1)) q (3085 . 2)) ((c form c (c (? . 2) q λ)) q (7510 . 2)) ((c def c (c (? . 2) q set-first!)) q (8315 . 4)) ((c def c (c (? . 6) q gc:cons?)) q (6613 . 3)) ((q form ((lib "plai/scribblings/fake-mutator.rkt") allocator-setup)) q (2585 . 5)) ((c def c (c (? . 5) q read-root)) q (5454 . 3)) ((c def c (c (? . 6) q gc:set-rest!)) q (6497 . 4)) ((c def c (c (? . 1) q gc:deref)) q (1847 . 3)) ((c form c (c (? . 2) q define-values)) q (7298 . 2)) ((c def c (c (? . 6) q gc:closure-code-ptr)) q (6859 . 3)) ((c form c (c (? . 3) q empty)) q (3930 . 2)) ((c def c (c (? . 1) q gc:set-rest!)) q (2345 . 4)) ((c form c (c (? . 3) q set!)) q (2832 . 2)) ((c def c (c (? . 0) q print-only-errors)) q (726 . 3)) ((c def c (c (? . 2) q =)) q (7811 . 2)) ((c def c (c (? . 2) q rest)) q (8268 . 3)) ((c def c (c (? . 7) q save-random-mutator)) q (8729 . 14)) ((c def c (c (? . 0) q abridged-test-output)) q (469 . 3)) ((c form c (c (? . 2) q halt-on-errors)) q (8494 . 2)) ((c def c (c (? . 3) q symbol=?)) q (3429 . 2)) ((c def c (c (? . 3) q print-only-errors)) q (3943 . 2)) ((c def c (c (? . 2) q sub1)) q (7613 . 2)) ((c def c (c (? . 6) q gc:closure)) q (6737 . 4)) ((c def c (c (? . 3) q symbol?)) q (3400 . 2)) ((c def c (c (? . 5) q heap-size)) q (5061 . 2)) ((c form c (c (? . 2) q quote)) q (7372 . 2)) ((c form c (c (? . 5) q with-heap)) q (5792 . 4)) ((c def c (c (? . 2) q cons?)) q (8169 . 3)) ((c form c (c (? . 0) q test/pred)) q (301 . 2)) ((c def c (c (? . 5) q location?)) q (5115 . 3)) ((c def c (c (? . 2) q zero?)) q (7639 . 2)) ((c def c (c (? . 1) q gc:cons?)) q (2461 . 3)) ((c form c (c (? . 2) q define)) q (7398 . 2)) ((c def c (c (? . 4) q heap-value?)) q (1157 . 3)) ((c def c (c (? . 2) q add1)) q (7587 . 2)) ((c def c (c (? . 1) q gc:set-first!)) q (2226 . 4)) ((c form c (c (? . 3) q case)) q (2758 . 2)) ((c form c (c (? . 3) q cond)) q (2746 . 2)) ((c form c (c (? . 2) q if)) q (7243 . 2)) ((c def c (c (? . 2) q <=)) q (7880 . 2)) ((c def c (c (? . 6) q gc:rest)) q (6304 . 3)) ((c form c (c (? . 3) q define-values)) q (2770 . 2)) ((c def c (c (? . 3) q halt-on-errors)) q (3982 . 2)) ((c def c (c (? . 3) q empty?)) q (3518 . 2)) ((c form c (c (? . 2) q set!)) q (7360 . 2)) ((c def c (c (? . 3) q rest)) q (3740 . 3)) ((c form c (c (? . 2) q empty)) q (8456 . 2)) ((c def c (c (? . 2) q >=)) q (7904 . 2)) ((c def c (c (? . 3) q set-first!)) q (3787 . 4)) ((c form c (c (? . 3) q and)) q (2725 . 2)) ((q form ((lib "plai/scribblings/fake-mutator2.rkt") allocator-setup)) q (7113 . 5)) ((c form c (c (? . 3) q λ)) q (2982 . 2)) ((c def c (c (? . 8) q find-heap-values)) q (4950 . 3)) ((c def c (c (? . 5) q simple-root)) q (5601 . 3)) ((c def c (c (? . 2) q empty?)) q (8046 . 2)) ((c def c (c (? . 5) q heap-ref)) q (5367 . 3)) ((c def c (c (? . 3) q cons)) q (3571 . 4)) ((c def c (c (? . 4) q procedure-roots)) q (1546 . 3)) ((c def c (c (? . 5) q heap-value?)) q (5221 . 3)) ((c form c (c (? . 3) q let*)) q (2820 . 2)) ((c def c (c (? . 1) q gc:cons)) q (1982 . 4)) ((c def c (c (? . 2) q <)) q (7834 . 2)) ((c form c (c (? . 3) q let)) q (2791 . 2)) ((c form c (c (? . 2) q and)) q (7253 . 2)) ((c def c (c (? . 7) q find-heap-values)) q (9441 . 3)) ((c def c (c (? . 4) q read-root)) q (1399 . 3)) ((c def c (c (? . 1) q gc:flat?)) q (2523 . 3)) ((c form c (c (? . 2) q case)) q (7286 . 2)) ((c def c (c (? . 3) q -)) q (3161 . 2)) ((c form c (c (? . 3) q if)) q (2715 . 2)) ((c def c (c (? . 6) q gc:set-first!)) q (6378 . 4)) ((c def c (c (? . 3) q zero?)) q (3111 . 2)) ((c def c (c (? . 2) q >)) q (7857 . 2)) ((c form c (c (? . 2) q or)) q (7264 . 2)) ((c def c (c (? . 2) q symbol?)) q (7928 . 2)) ((c form c (c (? . 3) q printf)) q (4166 . 4)) ((c def c (c (? . 5) q heap-set!)) q (5278 . 4)) ((c def c (c (? . 2) q symbol=?)) q (7957 . 2)) ((c form c (c (? . 3) q test/value=?)) q (4109 . 2)) ((c def c (c (? . 6) q gc:flat?)) q (6675 . 3)) ((c def c (c (? . 3) q cons?)) q (3641 . 3)) ((c form c (c (? . 2) q lambda)) q (7456 . 2)) ((c form c (c (? . 3) q quote)) q (2844 . 2)) ((c def c (c (? . 2) q number?)) q (7987 . 2)) ((c def c (c (? . 3) q >=)) q (3376 . 2)) ((c form c (c (? . 2) q test/location=?)) q (8552 . 2)) ((c def c (c (? . 2) q +)) q (7666 . 2)) ((c def c (c (? . 6) q gc:closure?)) q (7048 . 3)) ((c form c (c (? . 3) q define)) q (2870 . 2)) ((c def c (c (? . 4) q heap-set!)) q (1214 . 4)) ((c form c (c (? . 2) q import-primitives)) q (8516 . 2)) ((c form c (c (? . 0) q define-type)) q (0 . 4)) ((c form c (c (? . 3) q import-primitives)) q (4018 . 2)) ((c def c (c (? . 3) q eq?)) q (3546 . 2)) ((c form c (c (? . 2) q let-values)) q (7330 . 2)) ((c def c (c (? . 3) q <=)) q (3352 . 2)) ((c form c (c (? . 2) q printf)) q (8657 . 4)) ((c def c (c (? . 2) q -)) q (7689 . 2)) ((q def ((lib "plai/scribblings/fake-web.rkt") start)) q (9552 . 3)) ((c def c (c (? . 3) q error)) q (3032 . 2)) ((c def c (c (? . 0) q error)) q (340 . 2)) ((c form c (c (? . 3) q test/location=?)) q (4054 . 2)) ((c def c (c (? . 6) q gc:first)) q (6229 . 3)) ((c def c (c (? . 1) q init-allocator)) q (1809 . 2)) ((c def c (c (? . 3) q +)) q (3138 . 2)) ((c def c (c (? . 0) q test-inexact-epsilon)) q (810 . 3)) ((c form c (c (? . 5) q with-roots)) q (5883 . 4)) ((c form c (c (? . 3) q let-values)) q (2802 . 2)) ((c def c (c (? . 2) q eq?)) q (8074 . 2)) ((c def c (c (? . 3) q >)) q (3329 . 2)) ((c def c (c (? . 3) q odd?)) q (3257 . 2)) ((c def c (c (? . 8) q save-random-mutator)) q (4238 . 14)) ((c form c (c (? . 2) q let*)) q (7348 . 2)) ((c def c (c (? . 3) q boolean?)) q (3488 . 2)) ((c form c (c (? . 3) q lambda)) q (2928 . 2)) ((c form c (c (? . 2) q print-only-errors)) q (8469 . 2)) ((c form c (c (? . 0) q test/regexp)) q (413 . 2)) ((c def c (c (? . 2) q first)) q (8220 . 3)) ((c def c (c (? . 3) q set-rest!)) q (3859 . 4)) ((c def c (c (? . 2) q boolean?)) q (8016 . 2)) ((c def c (c (? . 3) q even?)) q (3230 . 2)) ((c def c (c (? . 3) q <)) q (3306 . 2)) ((c def c (c (? . 6) q init-allocator)) q (5969 . 2)) ((c def c (c (? . 4) q heap-ref)) q (1303 . 3)) ((c def c (c (? . 3) q number?)) q (3459 . 2)) ((c def c (c (? . 4) q root?)) q (1106 . 3)) ((c def c (c (? . 3) q *)) q (3184 . 2))))
syntax
(define-type type-id variant ...)
 
variant = (variant-id (field-id contract-expr) ...)
syntax
(type-case datatype-id expr
   branch ...)
 
branch = (variant-id (field-id ...) result-expr ...)
       | (else result-expr ...)
syntax
(test result-expr expected-expr)
syntax
(test/pred result-expr pred?)
value
error : procedure?
syntax
(test/exn result-expr error-message)
syntax
(test/regexp result-expr error-message-regexp)
procedure
(abridged-test-output [abridge?]) -> void?
  abridge? : boolean? = false
procedure
(plai-catch-test-exn [catch?]) -> void?
  catch? : boolean? = true
procedure
(halt-on-errors [halt?]) -> void?
  halt? : boolean? = true
procedure
(print-only-errors [print?]) -> void?
  print? : boolean? = true
procedure
(test-inexact-epsilon epsilon) -> void?
  epsilon : number?
procedure
(plai-ignore-exn-strings ignore?) -> void?
  ignore? : boolean?
syntax
plai-all-test-results
procedure
(heap-size) -> exact-nonnegative-integer?
procedure
(location? v) -> boolean?
  v : any/c
procedure
(root? v) -> boolean?
  v : any/c
procedure
(heap-value? v) -> boolean?
  v : any/c
procedure
(heap-set! loc val) -> void?
  loc : location?
  val : heap-value?
procedure
(heap-ref loc) -> heap-value?
  loc : location?
syntax
(get-root-set id ...)
procedure
(read-root root) -> location?
  root : root?
procedure
(set-root! root loc) -> void?
  root : root?
  loc : location?
procedure
(procedure-roots proc) -> (listof root?)
  proc : procedure?
syntax
(with-heap heap-expr body-expr ...)
 
  heap-expr : (vectorof heap-value?)
syntax
(with-roots roots-expr expr1 expr2 ...)
 
  roots-expr : (listof location?)
procedure
(init-allocator) -> void?
procedure
(gc:deref loc) -> heap-value?
  loc : location?
procedure
(gc:alloc-flat val) -> location?
  val : heap-value?
procedure
(gc:cons first rest) -> location?
  first : location?
  rest : location?
procedure
(gc:first cons-cell) -> location?
  cons-cell : location?
procedure
(gc:rest cons-cell) -> location?
  cons-cell : location?
procedure
(gc:set-first! cons-cell first-value) -> void?
  cons-cell : location?
  first-value : location?
procedure
(gc:set-rest! cons-cell rest-value) -> void?
  cons-cell : location?
  rest-value : location?
procedure
(gc:cons? loc) -> boolean?
  loc : location?
procedure
(gc:flat? loc) -> boolean?
  loc : location?
syntax
(allocator-setup collector-module
                 heap-size)
 
heap-size = exact-nonnegative-integer
syntax
if
syntax
and
syntax
or
syntax
cond
syntax
case
syntax
define-values
syntax
let
syntax
let-values
syntax
let*
syntax
set!
syntax
quote
syntax
begin
syntax
(define (id arg-id ...) body-expression ...+)
syntax
(lambda (arg-id ...) body-expression ...+)
syntax
(λ (arg-id ...) body-expression ...+)
value
error : procedure?
value
add1 : procedure?
value
sub1 : procedure?
value
zero? : procedure?
value
+ : procedure?
value
- : procedure?
value
* : procedure?
value
/ : procedure?
value
even? : procedure?
value
odd? : procedure?
value
= : procedure?
value
< : procedure?
value
> : procedure?
value
<= : procedure?
value
>= : procedure?
value
symbol? : procedure?
value
symbol=? : procedure?
value
number? : procedure?
value
boolean? : procedure?
value
empty? : procedure?
value
eq? : procedure?
procedure
(cons hd tl) -> cons?
  hd : any/c
  tl : any/c
procedure
(cons? v) -> boolean?
  v : any/c
procedure
(first c) -> any/c
  c : cons?
procedure
(rest c) -> any/c
  c : cons?
procedure
(set-first! c v) -> void?
  c : cons?
  v : any/c
procedure
(set-rest! c v) -> void?
  c : cons?
  v : any/c
syntax
empty
value
print-only-errors : procedure?
value
halt-on-errors : procedure?
syntax
(import-primitives id ...)
syntax
(test/location=? mutator-expr1 mutator-expr2)
syntax
(test/value=? mutator-expr scheme-datum/quoted)
syntax
(printf format mutator-expr ...)
 
format = literal-string
procedure
(save-random-mutator  file                            
                      collector-name                  
                     [#:heap-values heap-values       
                      #:iterations iterations         
                      #:program-size program-size     
                      #:heap-size heap-size])     -> void?
  file : path-string?
  collector-name : string?
  heap-values : (cons heap-value? (listof heap-value?))
              = (list 0 1 -1 'x 'y #f #t '())
  iterations : exact-positive-integer? = 200
  program-size : exact-positive-integer? = 10
  heap-size : exact-positive-integer? = 100
procedure
(find-heap-values input) -> (listof heap-value?)
  input : (or/c path-string? input-port?)
procedure
(heap-size) -> exact-nonnegative-integer?
procedure
(location? v) -> boolean?
  v : any/c
procedure
(root? v) -> boolean?
  v : any/c
procedure
(heap-value? v) -> boolean?
  v : any/c
procedure
(heap-set! loc val) -> void?
  loc : location?
  val : heap-value?
procedure
(heap-ref loc) -> heap-value?
  loc : location?
syntax
(get-root-set)
procedure
(read-root root) -> location?
  root : root?
procedure
(set-root! root loc) -> void?
  root : root?
  loc : location?
procedure
(simple-root l) -> root?
  l : location?
procedure
(make-root name get set) -> root?
  name : symbol?
  get : (-> location?)
  set : (-> location? void?)
syntax
(with-heap heap-expr body-expr ...)
 
  heap-expr : (vectorof heap-value?)
syntax
(with-roots (root-var ...) expr1 expr2 ...)
 
  root-var : location?
procedure
(init-allocator) -> void?
procedure
(gc:deref loc) -> heap-value?
  loc : location?
procedure
(gc:alloc-flat val) -> location?
  val : heap-value?
procedure
(gc:cons first rest) -> location?
  first : root?
  rest : root?
procedure
(gc:first cons-cell) -> location?
  cons-cell : location?
procedure
(gc:rest cons-cell) -> location?
  cons-cell : location?
procedure
(gc:set-first! cons-cell first-value) -> void?
  cons-cell : location?
  first-value : location?
procedure
(gc:set-rest! cons-cell rest-value) -> void?
  cons-cell : location?
  rest-value : location?
procedure
(gc:cons? loc) -> boolean?
  loc : location?
procedure
(gc:flat? loc) -> boolean?
  loc : location?
procedure
(gc:closure code-ptr free-vars) -> location?
  code-ptr : heap-value?
  free-vars : (listof root?)
procedure
(gc:closure-code-ptr loc) -> heap-value?
  loc : location?
procedure
(gc:closure-env-ref loc i) -> location?
  loc : location?
  i : exact-nonnegative-integer?
procedure
(gc:closure? loc) -> boolean?
  loc : location?
syntax
(allocator-setup collector-module
                 heap-size)
 
heap-size = exact-nonnegative-integer
syntax
if
syntax
and
syntax
or
syntax
cond
syntax
case
syntax
define-values
syntax
let
syntax
let-values
syntax
let*
syntax
set!
syntax
quote
syntax
begin
syntax
(define (id arg-id ...) body-expression ...+)
syntax
(lambda (arg-id ...) body-expression ...+)
syntax
(λ (arg-id ...) body-expression ...+)
value
error : procedure?
value
add1 : procedure?
value
sub1 : procedure?
value
zero? : procedure?
value
+ : procedure?
value
- : procedure?
value
* : procedure?
value
/ : procedure?
value
even? : procedure?
value
odd? : procedure?
value
= : procedure?
value
< : procedure?
value
> : procedure?
value
<= : procedure?
value
>= : procedure?
value
symbol? : procedure?
value
symbol=? : procedure?
value
number? : procedure?
value
boolean? : procedure?
value
empty? : procedure?
value
eq? : procedure?
procedure
(cons hd tl) -> cons?
  hd : any/c
  tl : any/c
procedure
(cons? v) -> boolean?
  v : any/c
procedure
(first c) -> any/c
  c : cons?
procedure
(rest c) -> any/c
  c : cons?
procedure
(set-first! c v) -> void
  c : cons?
  v : any/c
procedure
(set-rest! c v) -> void
  c : cons?
  v : any/c
syntax
empty
syntax
print-only-errors
syntax
halt-on-errors
syntax
(import-primitives id ...)
syntax
(test/location=? mutator-expr1 mutator-expr2)
syntax
(test/value=? mutator-expr datum/quoted)
syntax
(printf format mutator-expr ...)
 
format = literal-string
procedure
(save-random-mutator  file                            
                      collector-name                  
                     [#:heap-values heap-values       
                      #:iterations iterations         
                      #:program-size program-size     
                      #:heap-size heap-size])     -> void?
  file : path-string?
  collector-name : string?
  heap-values : (cons heap-value? (listof heap-value?))
              = (list 0 1 -1 'x 'y #f #t '())
  iterations : exact-positive-integer? = 200
  program-size : exact-positive-integer? = 10
  heap-size : exact-positive-integer? = 100
procedure
(find-heap-values input) -> (listof heap-value?)
  input : (or/c path-string? input-port?)
procedure
(start initial-request) -> response?
  initial-request : request?
